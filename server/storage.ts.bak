import { prisma } from '@shared/db';
import {
  User,
  ProfessionalProfile,
  CompanyProfile,
  Project,
  Post,
  Message,
  Feedback,
  Connection,
  Notification,
  NotificationPreferences,
  ProjectSubscription,
  ProjectApplication,
  ProjectPreventive,
  type RegisterUser,
  type InsertProfessionalProfile,
  type InsertCompanyProfile,
  type InsertProject,
  type InsertPost,
  type InsertMessage,
  type InsertFeedback,
  type InsertConnection,
  type InsertNotification,
  type InsertNotificationPreferences,
  type InsertProjectSubscription,
  type InsertProjectApplication,
  type InsertProjectPreventive,
} from "@shared/schema";

// Interface for storage operations
export interface IStorage {
  // User operations
  getUser(id: string): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  createUser(user: Omit<RegisterUser, 'confirmPassword'>): Promise<User>;
  upsertUser(user: { id?: string; email?: string; firstName?: string; lastName?: string; profileImageUrl?: string }): Promise<User>;
  updateUser(id: string, updates: Partial<User>): Promise<User | undefined>;
  updateUserLanguage(id: string, language: string): Promise<User>;
  
  // Professional profile operations
  getProfessionalProfile(userId: string): Promise<ProfessionalProfile | undefined>;
  createProfessionalProfile(profile: InsertProfessionalProfile): Promise<ProfessionalProfile>;
  updateProfessionalProfile(userId: string, profile: Partial<InsertProfessionalProfile>): Promise<ProfessionalProfile>;
  searchProfessionals(filters: {
    skills?: string[];
    availability?: string;
    seniorityLevel?: string;
    minRate?: number;
    maxRate?: number;
    search?: string;
    excludeUserId?: string;
  }): Promise<any[]>;
  
  // Company profile operations
  getCompanyProfile(userId: string): Promise<CompanyProfile | undefined>;
  createCompanyProfile(profile: InsertCompanyProfile): Promise<CompanyProfile>;
  updateCompanyProfile(userId: string, profile: Partial<InsertCompanyProfile>): Promise<CompanyProfile>;
  getCompanies(excludeUserId?: string): Promise<any[]>;
  getCompanyWithProjects(id: string): Promise<any | undefined>;
  
  // Project operations
  getProject(id: string): Promise<any | undefined>;
  getProjects(filters?: { status?: string; companyUserId?: string }): Promise<any[]>;
  createProject(project: InsertProject): Promise<Project>;
  updateProject(id: string, project: Partial<InsertProject>): Promise<Project>;
  
  // Post operations
  getPosts(filters?: { userId?: string; isPublic?: boolean }): Promise<any[]>;
  createPost(post: InsertPost): Promise<Post>;
  updatePost(postId: string, userId: string, content: string): Promise<Post>;
  deletePost(postId: string, userId: string): Promise<void>;
  likePost(postId: string, userId: string): Promise<void>;
  unlikePost(postId: string, userId: string): Promise<void>;
  addComment(postId: string, userId: string, content: string): Promise<void>;
  updateComment(commentId: string, userId: string, content: string): Promise<void>;
  deleteComment(commentId: string, userId: string): Promise<void>;
  getPostComments(postId: string): Promise<Array<{ id: string; content: string; createdAt: string; user: User; likesCount: number }>>;
  getComment(commentId: string): Promise<{ id: string; userId: string; content: string } | undefined>;
  likeComment(commentId: string, userId: string): Promise<void>;
  unlikeComment(commentId: string, userId: string): Promise<void>;
  likeProject(projectId: string, userId: string): Promise<void>;
  unlikeProject(projectId: string, userId: string): Promise<void>;
  
  // Message operations
  getMessages(senderId: string, receiverId: string): Promise<Message[]>;
  getConversations(userId: string): Promise<Array<{
    otherUser: User;
    lastMessage: Message;
    unreadCount: number;
  }>>;
  getUnreadMessageCount(userId: string): Promise<number>;
  createMessage(message: InsertMessage): Promise<Message>;
  markMessageAsRead(messageId: string): Promise<void>;
  markMessagesAsRead(userId1: string, userId2: string): Promise<void>;
  
  // Connection operations
  getConnections(userId: string): Promise<any[]>;
  getConnection(requesterId: string, addresseeId: string): Promise<Connection | undefined>;
  createConnection(connection: InsertConnection): Promise<Connection>;
  updateConnectionStatus(connectionId: string, status: string): Promise<Connection>;
  areUsersConnected(userId1: string, userId2: string): Promise<boolean>;
  
  // Feedback operations
  getFeedback(toUserId: string): Promise<any[]>;
  createFeedback(feedback: InsertFeedback): Promise<Feedback>;
  
  // Notification operations
  getNotifications(userId: string): Promise<Notification[]>;
  getUnreadNotificationCount(userId: string): Promise<number>;
  createNotification(notification: InsertNotification): Promise<Notification>;
  markNotificationAsRead(notificationId: string): Promise<void>;
  markAllNotificationsAsRead(userId: string): Promise<void>;
  getNotificationPreferences(userId: string): Promise<NotificationPreferences | undefined>;
  createNotificationPreferences(preferences: InsertNotificationPreferences): Promise<NotificationPreferences>;
  updateNotificationPreferences(userId: string, preferences: Partial<InsertNotificationPreferences>): Promise<NotificationPreferences>;
  
  // Project subscription operations
  getProjectSubscriptions(userId: string): Promise<any[]>;
  createProjectSubscription(subscription: InsertProjectSubscription): Promise<ProjectSubscription>;
  deleteProjectSubscription(projectId: string, userId: string): Promise<void>;
  isUserSubscribedToProject(projectId: string, userId: string): Promise<boolean>;
  getProjectSubscribers(projectId: string): Promise<User[]>;
  
  // Project application operations
  getProjectApplications(projectId: string): Promise<any[]>;
  getUserApplications(userId: string): Promise<any[]>;
  createProjectApplication(application: InsertProjectApplication): Promise<ProjectApplication>;
  updateProjectApplicationStatus(applicationId: string, status: string, respondedBy: string): Promise<ProjectApplication>;
  getProjectApplicationsCount(projectId: string): Promise<number>;
  getAcceptedProjectApplicationsCount(projectId: string): Promise<number>;
  
  // Project preventive operations
  getProjectPreventives(userId: string): Promise<ProjectPreventive[]>;
  createProjectPreventive(preventive: InsertProjectPreventive): Promise<ProjectPreventive>;
  updateProjectPreventive(id: string, preventive: Partial<InsertProjectPreventive>): Promise<ProjectPreventive>;
  deleteProjectPreventive(id: string): Promise<void>;
  validateProjectAgainstPreventives(project: InsertProject, userId: string): Promise<string[]>;
}

export class DatabaseStorage implements IStorage {
  // User operations
  async getUser(id: string): Promise<User | undefined> {
    try {
      const user = await prisma.user.findUnique({
        where: { id }
      });
      return user || undefined;
    } catch (error) {
      console.error('Error getting user:', error);
      return undefined;
    }
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    try {
      const user = await prisma.user.findUnique({
        where: { email }
      });
      return user || undefined;
    } catch (error) {
      console.error('Error getting user by email:', error);
      return undefined;
    }
  }

  async createUser(user: Omit<RegisterUser, 'confirmPassword'>): Promise<User> {
    try {
      return await prisma.user.create({
        data: user
      });
    } catch (error) {
      console.error('Error creating user:', error);
      throw error;
    }
  }

  async upsertUser(user: { id?: string; email?: string; firstName?: string; lastName?: string; profileImageUrl?: string }): Promise<User> {
    try {
      if (user.id) {
        // Update existing user
        return await prisma.user.update({
          where: { id: user.id },
          data: {
            firstName: user.firstName,
            lastName: user.lastName,
            profileImageUrl: user.profileImageUrl,
          }
        });
      } else {
        // Create new user (for OAuth)
        return await prisma.user.create({
          data: {
            email: user.email || '',
            password: '', // Default for OAuth users
            firstName: user.firstName,
            lastName: user.lastName,
            profileImageUrl: user.profileImageUrl,
          }
        });
      }
    } catch (error) {
      console.error('Error upserting user:', error);
      throw error;
    }
  }

  async updateUser(id: string, updates: Partial<User>): Promise<User | undefined> {
    try {
      const user = await prisma.user.update({
        where: { id },
        data: updates
      });
      return user || undefined;
    } catch (error) {
      console.error('Error updating user:', error);
      return undefined;
    }
  }

  async updateUserLanguage(id: string, language: string): Promise<User> {
    try {
      return await prisma.user.update({
        where: { id },
        data: { language }
      });
    } catch (error) {
      console.error('Error updating user language:', error);
      throw error;
    }
  }

  // Professional profile operations
  async getProfessionalProfile(userId: string): Promise<ProfessionalProfile | undefined> {
    try {
      const profile = await prisma.professionalProfile.findUnique({
        where: { userId }
      });
      return profile || undefined;
    } catch (error) {
      console.error('Error getting professional profile:', error);
      return undefined;
    }
  }

  async createProfessionalProfile(profile: InsertProfessionalProfile): Promise<ProfessionalProfile> {
    try {
      return await prisma.professionalProfile.create({
        data: profile
      });
    } catch (error) {
      console.error('Error creating professional profile:', error);
      throw error;
    }
  }

  async updateProfessionalProfile(userId: string, profile: Partial<InsertProfessionalProfile>): Promise<ProfessionalProfile> {
    try {
      return await prisma.professionalProfile.upsert({
        where: { userId },
        update: profile,
        create: { userId, ...profile }
      });
    } catch (error) {
      console.error('Error updating professional profile:', error);
      throw error;
    }
  }

  async searchProfessionals(filters: {
    skills?: string[];
    availability?: string;
    seniorityLevel?: string;
    minRate?: number;
    maxRate?: number;
    search?: string;
    excludeUserId?: string;
  }): Promise<any[]> {
    try {
      const where: any = {};

      if (filters.skills?.length) {
        where.skills = { hasSome: filters.skills };
      }

      if (filters.availability) {
        where.availability = filters.availability;
      }

      if (filters.seniorityLevel) {
        where.seniorityLevel = filters.seniorityLevel;
      }

      if (filters.minRate !== undefined) {
        where.hourlyRate = { gte: filters.minRate };
      }

      if (filters.maxRate !== undefined) {
        where.hourlyRate = { ...where.hourlyRate, lte: filters.maxRate };
      }

      if (filters.excludeUserId) {
        where.userId = { not: filters.excludeUserId };
      }

      let profiles = await prisma.professionalProfile.findMany({
        where,
        include: { user: true },
        orderBy: { createdAt: 'desc' }
      });

      // Apply search filter if provided
      if (filters.search) {
        const searchTerm = filters.search.toLowerCase();
        profiles = profiles.filter(profile => {
          const fullName = `${profile.user.firstName || ''} ${profile.user.lastName || ''}`.toLowerCase();
          const title = profile.title?.toLowerCase() || '';
          const bio = profile.bio?.toLowerCase() || '';
          const skills = (profile.skills || []).join(' ').toLowerCase();
          
          return fullName.includes(searchTerm) ||
                 title.includes(searchTerm) ||
                 bio.includes(searchTerm) ||
                 skills.includes(searchTerm);
        });
      }

      return profiles;
    } catch (error) {
      console.error('Error searching professionals:', error);
      return [];
    }
  }

  // Company profile operations
  async getCompanyProfile(userId: string): Promise<CompanyProfile | undefined> {
    try {
      const profile = await prisma.companyProfile.findUnique({
        where: { userId }
      });
      return profile || undefined;
    } catch (error) {
      console.error('Error getting company profile:', error);
      return undefined;
    }
  }

  async createCompanyProfile(profile: InsertCompanyProfile): Promise<CompanyProfile> {
    try {
      return await prisma.companyProfile.create({
        data: profile
      });
    } catch (error) {
      console.error('Error creating company profile:', error);
      throw error;
    }
  }

  async updateCompanyProfile(userId: string, profile: Partial<InsertCompanyProfile>): Promise<CompanyProfile> {
    try {
      return await prisma.companyProfile.upsert({
        where: { userId },
        update: profile,
        create: { userId, ...profile }
      });
    } catch (error) {
      console.error('Error updating company profile:', error);
      throw error;
    }
  }

  async getCompanies(excludeUserId?: string): Promise<any[]> {
    try {
      const where: any = {};
      if (excludeUserId) {
        where.userId = { not: excludeUserId };
      }

      const companies = await prisma.companyProfile.findMany({
        where,
        include: { 
          user: true,
          _count: {
            select: { projects: true }
          }
        },
        orderBy: { createdAt: 'desc' }
      });

      return companies.map(company => ({
        ...company,
        projectsCount: company._count.projects
      }));
    } catch (error) {
      console.error('Error getting companies:', error);
      return [];
    }
  }

  async getCompanyWithProjects(id: string): Promise<any | undefined> {
    try {
      const company = await prisma.companyProfile.findUnique({
        where: { userId: id },
        include: { 
          user: true,
          projects: true
        }
      });
      
      return company || undefined;
    } catch (error) {
      console.error('Error getting company with projects:', error);
      return undefined;
    }
  }

  // Project operations
  async getProject(id: string): Promise<any | undefined> {
    try {
      const project = await prisma.project.findUnique({
        where: { id },
        include: { company: true }
      });
      
      return project || undefined;
    } catch (error) {
      console.error('Error getting project:', error);
      return undefined;
    }
  }

  async getProjects(filters?: { status?: string; companyUserId?: string }): Promise<any[]> {
    try {
      const where: any = {};
      
      if (filters?.status) {
        where.status = filters.status;
      }
      
      if (filters?.companyUserId) {
        where.companyUserId = filters.companyUserId;
      }

      const projects = await prisma.project.findMany({
        where,
        include: { company: true },
        orderBy: { createdAt: 'desc' }
      });

      return projects;
    } catch (error) {
      console.error('Error getting projects:', error);
      return [];
    }
  }

  async createProject(project: InsertProject): Promise<Project> {
    try {
      return await prisma.project.create({
        data: project
      });
    } catch (error) {
      console.error('Error creating project:', error);
      throw error;
    }
  }

  async updateProject(id: string, project: Partial<InsertProject>): Promise<Project> {
    try {
      return await prisma.project.update({
        where: { id },
        data: project
      });
    } catch (error) {
      console.error('Error updating project:', error);
      throw error;
    }
  }

  // Post operations
  async getPosts(filters?: { userId?: string; isPublic?: boolean }): Promise<any[]> {
    try {
      const where: any = {};
      
      if (filters?.userId) {
        where.userId = filters.userId;
      }
      
      if (filters?.isPublic !== undefined) {
        where.isPublic = filters.isPublic;
      }

      const posts = await prisma.post.findMany({
        where,
        include: { user: true },
        orderBy: { createdAt: 'desc' }
      });

      return posts;
    } catch (error) {
      console.error('Error getting posts:', error);
      return [];
    }
  }

  async createPost(post: InsertPost): Promise<Post> {
    try {
      return await prisma.post.create({
        data: post
      });
    } catch (error) {
      console.error('Error creating post:', error);
      throw error;
    }
  }

  async updatePost(postId: string, userId: string, content: string): Promise<Post> {
    try {
      return await prisma.post.update({
        where: { 
          id: postId,
          userId: userId
        },
        data: { content }
      });
    } catch (error) {
      console.error('Error updating post:', error);
      throw error;
    }
  }

  async deletePost(postId: string, userId: string): Promise<void> {
    try {
      // Using transaction to delete post and related data
      await prisma.$transaction(async (tx) => {
        // Delete post likes
        await tx.postLike.deleteMany({ where: { postId } });
        
        // Get comment IDs for this post
        const comments = await tx.postComment.findMany({
          where: { postId },
          select: { id: true }
        });
        const commentIds = comments.map(c => c.id);
        
        // Delete comment likes
        if (commentIds.length > 0) {
          await tx.commentLike.deleteMany({
            where: { commentId: { in: commentIds } }
          });
        }
        
        // Delete comments
        await tx.postComment.deleteMany({ where: { postId } });
        
        // Delete the post
        await tx.post.delete({
          where: { 
            id: postId,
            userId: userId
          }
        });
      });
    } catch (error) {
      console.error('Error deleting post:', error);
      throw error;
    }
  }

  async likePost(postId: string, userId: string): Promise<void> {
    try {
      await prisma.$transaction(async (tx) => {
        // Create like if it doesn't exist
        await tx.postLike.upsert({
          where: {
            postId_userId: { postId, userId }
          },
          update: {},
          create: { postId, userId }
        });
        
        // Increment likes count
        await tx.post.update({
          where: { id: postId },
          data: { likesCount: { increment: 1 } }
        });
      });
    } catch (error) {
      console.error('Error liking post:', error);
      throw error;
    }
  }

  async unlikePost(postId: string, userId: string): Promise<void> {
    try {
      await prisma.$transaction(async (tx) => {
        const deleted = await tx.postLike.delete({
          where: {
            postId_userId: { postId, userId }
          }
        });
        
        if (deleted) {
          await tx.post.update({
            where: { id: postId },
            data: { likesCount: { decrement: 1 } }
          });
        }
      });
    } catch (error) {
      console.error('Error unliking post:', error);
      throw error;
    }
  }

  async addComment(postId: string, userId: string, content: string): Promise<void> {
    try {
      await prisma.$transaction(async (tx) => {
        await tx.postComment.create({
          data: { postId, userId, content }
        });
        
        await tx.post.update({
          where: { id: postId },
          data: { commentsCount: { increment: 1 } }
        });
      });
    } catch (error) {
      console.error('Error adding comment:', error);
      throw error;
    }
  }

  async updateComment(commentId: string, userId: string, content: string): Promise<void> {
    try {
      await prisma.postComment.update({
        where: { 
          id: commentId,
          userId: userId
        },
        data: { content }
      });
    } catch (error) {
      console.error('Error updating comment:', error);
      throw error;
    }
  }

  async deleteComment(commentId: string, userId: string): Promise<void> {
    try {
      await prisma.$transaction(async (tx) => {
        const comment = await tx.postComment.findUnique({
          where: { id: commentId },
          select: { postId: true, userId: true }
        });
        
        if (comment && comment.userId === userId) {
          // Delete comment likes
          await tx.commentLike.deleteMany({ where: { commentId } });
          
          // Delete comment
          await tx.postComment.delete({ where: { id: commentId } });
          
          // Decrement comments count
          await tx.post.update({
            where: { id: comment.postId },
            data: { commentsCount: { decrement: 1 } }
          });
        }
      });
    } catch (error) {
      console.error('Error deleting comment:', error);
      throw error;
    }
  }

  async getPostComments(postId: string): Promise<Array<{ id: string; content: string; createdAt: string; user: User; likesCount: number }>> {
    try {
      const comments = await prisma.postComment.findMany({
        where: { postId },
        include: { user: true },
        orderBy: { createdAt: 'desc' }
      });

      return comments.map(comment => ({
        id: comment.id,
        content: comment.content,
        createdAt: comment.createdAt.toISOString(),
        user: comment.user,
        likesCount: comment.likesCount
      }));
    } catch (error) {
      console.error('Error getting post comments:', error);
      return [];
    }
  }

  async getComment(commentId: string): Promise<{ id: string; userId: string; content: string } | undefined> {
    try {
      const comment = await prisma.postComment.findUnique({
        where: { id: commentId }
      });
      
      if (!comment) return undefined;

      return {
        id: comment.id,
        userId: comment.userId,
        content: comment.content
      };
    } catch (error) {
      console.error('Error getting comment:', error);
      return undefined;
    }
  }

  async likeComment(commentId: string, userId: string): Promise<void> {
    try {
      await prisma.$transaction(async (tx) => {
        await tx.commentLike.upsert({
          where: {
            commentId_userId: { commentId, userId }
          },
          update: {},
          create: { commentId, userId }
        });
        
        await tx.postComment.update({
          where: { id: commentId },
          data: { likesCount: { increment: 1 } }
        });
      });
    } catch (error) {
      console.error('Error liking comment:', error);
      throw error;
    }
  }

  async unlikeComment(commentId: string, userId: string): Promise<void> {
    try {
      await prisma.$transaction(async (tx) => {
        const deleted = await tx.commentLike.delete({
          where: {
            commentId_userId: { commentId, userId }
          }
        });
        
        if (deleted) {
          await tx.postComment.update({
            where: { id: commentId },
            data: { likesCount: { decrement: 1 } }
          });
        }
      });
    } catch (error) {
      console.error('Error unliking comment:', error);
      throw error;
    }
  }

  async likeProject(projectId: string, userId: string): Promise<void> {
    try {
      await prisma.$transaction(async (tx) => {
        await tx.projectLike.upsert({
          where: {
            projectId_userId: { projectId, userId }
          },
          update: {},
          create: { projectId, userId }
        });
        
        await tx.project.update({
          where: { id: projectId },
          data: { likesCount: { increment: 1 } }
        });
      });
    } catch (error) {
      console.error('Error liking project:', error);
      throw error;
    }
  }

  async unlikeProject(projectId: string, userId: string): Promise<void> {
    try {
      await prisma.$transaction(async (tx) => {
        const deleted = await tx.projectLike.delete({
          where: {
            projectId_userId: { projectId, userId }
          }
        });
        
        if (deleted) {
          await tx.project.update({
            where: { id: projectId },
            data: { likesCount: { decrement: 1 } }
          });
        }
      });
    } catch (error) {
      console.error('Error unliking project:', error);
      throw error;
    }
  }

  // Message operations
  async getMessages(senderId: string, receiverId: string): Promise<Message[]> {
    try {
      const messages = await prisma.message.findMany({
        where: {
          OR: [
            { senderId, receiverId },
            { senderId: receiverId, receiverId: senderId }
          ]
        },
        orderBy: { createdAt: 'asc' }
      });

      return messages;
    } catch (error) {
      console.error('Error getting messages:', error);
      return [];
    }
  }

  async getConversations(userId: string): Promise<Array<{
    otherUser: User;
    lastMessage: Message;
    unreadCount: number;
  }>> {
    try {
      // Get all unique conversation partners
      const conversations = await prisma.message.groupBy({
        by: ['senderId', 'receiverId'],
        where: {
          OR: [
            { senderId: userId },
            { receiverId: userId }
          ]
        }
      });

      const conversationUserIds = new Set<string>();
      conversations.forEach(conv => {
        if (conv.senderId !== userId) conversationUserIds.add(conv.senderId);
        if (conv.receiverId !== userId) conversationUserIds.add(conv.receiverId);
      });

      const result = [];
      for (const otherUserId of conversationUserIds) {
        // Get other user
        const otherUser = await prisma.user.findUnique({
          where: { id: otherUserId }
        });
        
        // Get last message
        const lastMessage = await prisma.message.findFirst({
          where: {
            OR: [
              { senderId: userId, receiverId: otherUserId },
              { senderId: otherUserId, receiverId: userId }
            ]
          },
          orderBy: { createdAt: 'desc' }
        });
        
        // Get unread count
        const unreadCount = await prisma.message.count({
          where: {
            senderId: otherUserId,
            receiverId: userId,
            isRead: false
          }
        });

        if (otherUser && lastMessage) {
          result.push({
            otherUser,
            lastMessage,
            unreadCount
          });
        }
      }

      return result.sort((a, b) => 
        new Date(b.lastMessage.createdAt).getTime() - new Date(a.lastMessage.createdAt).getTime()
      );
    } catch (error) {
      console.error('Error getting conversations:', error);
      return [];
    }
  }

  async getUnreadMessageCount(userId: string): Promise<number> {
    try {
      return await prisma.message.count({
        where: {
          receiverId: userId,
          isRead: false
        }
      });
    } catch (error) {
      console.error('Error getting unread message count:', error);
      return 0;
    }
  }

  async createMessage(message: InsertMessage): Promise<Message> {
    try {
      return await prisma.message.create({
        data: message
      });
    } catch (error) {
      console.error('Error creating message:', error);
      throw error;
    }
  }

  async markMessageAsRead(messageId: string): Promise<void> {
    try {
      await prisma.message.update({
        where: { id: messageId },
        data: { isRead: true }
      });
    } catch (error) {
      console.error('Error marking message as read:', error);
      throw error;
    }
  }

  async markMessagesAsRead(userId1: string, userId2: string): Promise<void> {
    try {
      await prisma.message.updateMany({
        where: {
          senderId: userId2,
          receiverId: userId1,
          isRead: false
        },
        data: { isRead: true }
      });
    } catch (error) {
      console.error('Error marking messages as read:', error);
      throw error;
    }
  }

  // Connection operations
  async getConnections(userId: string): Promise<any[]> {
    try {
      const connections = await prisma.connection.findMany({
        where: {
          OR: [
            { requesterId: userId },
            { addresseeId: userId }
          ],
          status: 'ACCEPTED'
        },
        include: {
          requester: true,
          addressee: true
        }
      });

      return connections;
    } catch (error) {
      console.error('Error getting connections:', error);
      return [];
    }
  }

  async getConnection(requesterId: string, addresseeId: string): Promise<Connection | undefined> {
    try {
      const connection = await prisma.connection.findFirst({
        where: {
          OR: [
            { requesterId, addresseeId },
            { requesterId: addresseeId, addresseeId: requesterId }
          ]
        }
      });
      return connection || undefined;
    } catch (error) {
      console.error('Error getting connection:', error);
      return undefined;
    }
  }

  async createConnection(connection: InsertConnection): Promise<Connection> {
    try {
      return await prisma.connection.create({
        data: connection
      });
    } catch (error) {
      console.error('Error creating connection:', error);
      throw error;
    }
  }

  async updateConnectionStatus(connectionId: string, status: string): Promise<Connection> {
    try {
      return await prisma.connection.update({
        where: { id: connectionId },
        data: { status: status as any }
      });
    } catch (error) {
      console.error('Error updating connection status:', error);
      throw error;
    }
  }

  async areUsersConnected(userId1: string, userId2: string): Promise<boolean> {
    try {
      const connection = await prisma.connection.findFirst({
        where: {
          OR: [
            { requesterId: userId1, addresseeId: userId2 },
            { requesterId: userId2, addresseeId: userId1 }
          ],
          status: 'ACCEPTED'
        }
      });
      return !!connection;
    } catch (error) {
      console.error('Error checking if users are connected:', error);
      return false;
    }
  }

  // Feedback operations
  async getFeedback(toUserId: string): Promise<any[]> {
    try {
      const feedback = await prisma.feedback.findMany({
        where: { toUserId },
        include: {
          fromUser: true,
          project: true
        },
        orderBy: { createdAt: 'desc' }
      });

      return feedback;
    } catch (error) {
      console.error('Error getting feedback:', error);
      return [];
    }
  }

  async createFeedback(feedback: InsertFeedback): Promise<Feedback> {
    try {
      return await prisma.feedback.create({
        data: feedback
      });
    } catch (error) {
      console.error('Error creating feedback:', error);
      throw error;
    }
  }

  // Notification operations
  async getNotifications(userId: string): Promise<Notification[]> {
    try {
      return await prisma.notification.findMany({
        where: { userId },
        orderBy: { createdAt: 'desc' },
        take: 50
      });
    } catch (error) {
      console.error('Error getting notifications:', error);
      return [];
    }
  }

  async getUnreadNotificationCount(userId: string): Promise<number> {
    try {
      return await prisma.notification.count({
        where: { userId, isRead: false }
      });
    } catch (error) {
      console.error('Error getting unread notification count:', error);
      return 0;
    }
  }

  async createNotification(notification: InsertNotification): Promise<Notification> {
    try {
      return await prisma.notification.create({
        data: notification
      });
    } catch (error) {
      console.error('Error creating notification:', error);
      throw error;
    }
  }

  async markNotificationAsRead(notificationId: string): Promise<void> {
    try {
      await prisma.notification.update({
        where: { id: notificationId },
        data: { isRead: true }
      });
    } catch (error) {
      console.error('Error marking notification as read:', error);
      throw error;
    }
  }

  async markAllNotificationsAsRead(userId: string): Promise<void> {
    try {
      await prisma.notification.updateMany({
        where: { userId, isRead: false },
        data: { isRead: true }
      });
    } catch (error) {
      console.error('Error marking all notifications as read:', error);
      throw error;
    }
  }

  async getNotificationPreferences(userId: string): Promise<NotificationPreferences | undefined> {
    try {
      const preferences = await prisma.notificationPreferences.findUnique({
        where: { userId }
      });
      return preferences || undefined;
    } catch (error) {
      console.error('Error getting notification preferences:', error);
      return undefined;
    }
  }

  async createNotificationPreferences(preferences: InsertNotificationPreferences): Promise<NotificationPreferences> {
    try {
      return await prisma.notificationPreferences.create({
        data: preferences
      });
    } catch (error) {
      console.error('Error creating notification preferences:', error);
      throw error;
    }
  }

  async updateNotificationPreferences(userId: string, preferences: Partial<InsertNotificationPreferences>): Promise<NotificationPreferences> {
    try {
      return await prisma.notificationPreferences.upsert({
        where: { userId },
        update: preferences,
        create: { userId, ...preferences }
      });
    } catch (error) {
      console.error('Error updating notification preferences:', error);
      throw error;
    }
  }

  // Project subscription operations
  async getProjectSubscriptions(userId: string): Promise<any[]> {
    try {
      const subscriptions = await prisma.projectSubscription.findMany({
        where: { userId },
        include: {
          project: {
            include: { company: true }
          }
        },
        orderBy: { createdAt: 'desc' }
      });

      return subscriptions;
    } catch (error) {
      console.error('Error getting project subscriptions:', error);
      return [];
    }
  }

  async createProjectSubscription(subscription: InsertProjectSubscription): Promise<ProjectSubscription> {
    try {
      return await prisma.projectSubscription.upsert({
        where: {
          projectId_userId: {
            projectId: subscription.projectId,
            userId: subscription.userId
          }
        },
        update: {},
        create: subscription
      });
    } catch (error) {
      console.error('Error creating project subscription:', error);
      throw error;
    }
  }

  async deleteProjectSubscription(projectId: string, userId: string): Promise<void> {
    try {
      await prisma.projectSubscription.delete({
        where: {
          projectId_userId: { projectId, userId }
        }
      });
    } catch (error) {
      console.error('Error deleting project subscription:', error);
      throw error;
    }
  }

  async isUserSubscribedToProject(projectId: string, userId: string): Promise<boolean> {
    try {
      const subscription = await prisma.projectSubscription.findUnique({
        where: {
          projectId_userId: { projectId, userId }
        }
      });
      return !!subscription;
    } catch (error) {
      console.error('Error checking project subscription:', error);
      return false;
    }
  }

  async getProjectSubscribers(projectId: string): Promise<User[]> {
    try {
      const subscriptions = await prisma.projectSubscription.findMany({
        where: { projectId },
        include: { user: true }
      });
      
      return subscriptions.map(sub => sub.user);
    } catch (error) {
      console.error('Error getting project subscribers:', error);
      return [];
    }
  }

  // Project application operations
  async getProjectApplications(projectId: string): Promise<any[]> {
    try {
      const applications = await prisma.projectApplication.findMany({
        where: { projectId },
        include: { user: true },
        orderBy: { appliedAt: 'desc' }
      });

      return applications;
    } catch (error) {
      console.error('Error getting project applications:', error);
      return [];
    }
  }

  async getUserApplications(userId: string): Promise<any[]> {
    try {
      const applications = await prisma.projectApplication.findMany({
        where: { userId },
        include: {
          project: {
            include: { company: true }
          }
        },
        orderBy: { appliedAt: 'desc' }
      });

      return applications;
    } catch (error) {
      console.error('Error getting user applications:', error);
      return [];
    }
  }

  async createProjectApplication(application: InsertProjectApplication): Promise<ProjectApplication> {
    try {
      return await prisma.projectApplication.create({
        data: application
      });
    } catch (error) {
      console.error('Error creating project application:', error);
      throw error;
    }
  }

  async updateProjectApplicationStatus(applicationId: string, status: string, respondedBy: string): Promise<ProjectApplication> {
    try {
      return await prisma.projectApplication.update({
        where: { id: applicationId },
        data: {
          status: status as any,
          respondedBy,
          respondedAt: new Date()
        }
      });
    } catch (error) {
      console.error('Error updating project application status:', error);
      throw error;
    }
  }

  async getProjectApplicationsCount(projectId: string): Promise<number> {
    try {
      return await prisma.projectApplication.count({
        where: { projectId }
      });
    } catch (error) {
      console.error('Error getting project applications count:', error);
      return 0;
    }
  }

  async getAcceptedProjectApplicationsCount(projectId: string): Promise<number> {
    try {
      return await prisma.projectApplication.count({
        where: { projectId, status: 'ACCEPTED' }
      });
    } catch (error) {
      console.error('Error getting accepted project applications count:', error);
      return 0;
    }
  }

  // Project preventive operations
  async getProjectPreventives(userId: string): Promise<ProjectPreventive[]> {
    try {
      return await prisma.projectPreventive.findMany({
        where: { userId }
      });
    } catch (error) {
      console.error('Error getting project preventives:', error);
      return [];
    }
  }

  async createProjectPreventive(preventive: InsertProjectPreventive): Promise<ProjectPreventive> {
    try {
      return await prisma.projectPreventive.create({
        data: preventive
      });
    } catch (error) {
      console.error('Error creating project preventive:', error);
      throw error;
    }
  }

  async updateProjectPreventive(id: string, preventive: Partial<InsertProjectPreventive>): Promise<ProjectPreventive> {
    try {
      return await prisma.projectPreventive.update({
        where: { id },
        data: preventive
      });
    } catch (error) {
      console.error('Error updating project preventive:', error);
      throw error;
    }
  }

  async deleteProjectPreventive(id: string): Promise<void> {
    try {
      await prisma.projectPreventive.delete({
        where: { id }
      });
    } catch (error) {
      console.error('Error deleting project preventive:', error);
      throw error;
    }
  }

  async validateProjectAgainstPreventives(project: InsertProject, userId: string): Promise<string[]> {
    try {
      const preventives = await prisma.projectPreventive.findMany({
        where: {
          OR: [
            { userId, isActive: true },
            { isGlobal: true, isActive: true }
          ]
        }
      });

      const errors: string[] = [];

      for (const preventive of preventives) {
        try {
          const rule = JSON.parse(preventive.validationRule);
          // Here you would implement the actual validation logic
          // This is a simplified example
          if (rule.type === 'budgetMin' && project.budgetMin && project.budgetMin < rule.value) {
            errors.push(preventive.errorMessage);
          }
          if (rule.type === 'budgetMax' && project.budgetMax && project.budgetMax > rule.value) {
            errors.push(preventive.errorMessage);
          }
        } catch (parseError) {
          console.error('Error parsing validation rule:', parseError);
        }
      }

      return errors;
    } catch (error) {
      console.error('Error validating project against preventives:', error);
      return [];
    }
  }
}

// Export singleton instance
export const storage = new DatabaseStorage();

// Additional methods needed by routes.ts
export class ExtendedDatabaseStorage extends DatabaseStorage {

  // Application methods
======= REPLACE
        data: {
          status: status as any,
          respondedBy,
          respondedAt: new Date()
        }
      });
    } catch (error) {
      console.error('Error updating project application status:', error);
      throw error;
    }
  }

  // Export singleton instance
export const storage = new DatabaseStorage();

// Additional methods needed by routes.ts
export class ExtendedDatabaseStorage extends DatabaseStorage {

  // Application methods
  async hasUserAppliedToProject(projectId: string, userId: string): Promise<boolean> {
    try {
      const application = await prisma.projectApplication.findUnique({
        where: {
          projectId_userId: { projectId, userId }
        }
      });
      return !!application;
    } catch (error) {
      console.error('Error checking if user applied to project:', error);
      return false;
    }
  }

  async getAcceptedApplicationsCount(projectId: string): Promise<number> {
    return this.getAcceptedProjectApplicationsCount(projectId);
  }

  async getProjectApplicationById(applicationId: string): Promise<ProjectApplication | undefined> {
    try {
      const application = await prisma.projectApplication.findUnique({
        where: { id: applicationId },
        include: {
          user: true,
          project: { include: { company: true } }
        }
      });
      return application || undefined;
    } catch (error) {
      console.error('Error getting project application by id:', error);
      return undefined;
    }
  }

  async acceptProjectApplication(applicationId: string, respondedBy: string): Promise<ProjectApplication> {
    return this.updateProjectApplicationStatus(applicationId, "ACCEPTED", respondedBy);
  }

  async rejectProjectApplication(applicationId: string, respondedBy: string): Promise<ProjectApplication> {
    return this.updateProjectApplicationStatus(applicationId, "REJECTED", respondedBy);
  }

  async getUserProjectApplication(projectId: string, userId: string): Promise<ProjectApplication | undefined> {
    try {
      const application = await prisma.projectApplication.findUnique({
        where: {
          projectId_userId: { projectId, userId }
        },
        include: {
          project: { include: { company: true } }
        }
      });
      return application || undefined;
    } catch (error) {
      console.error('Error getting user project application:', error);
      return undefined;
    }
  }

  // Subscription methods
  async isSubscribedToProject(projectId: string, userId: string): Promise<boolean> {
    return this.isUserSubscribedToProject(projectId, userId);
  }

  async subscribeToProject(projectId: string, userId: string): Promise<void> {
    try {
      await this.createProjectSubscription({ projectId, userId });
    } catch (error) {
      console.error('Error subscribing to project:', error);
      throw error;
    }
  }

  async unsubscribeFromProject(projectId: string, userId: string): Promise<void> {
    try {
      await this.deleteProjectSubscription(projectId, userId);
    } catch (error) {
      console.error('Error unsubscribing from project:', error);
      throw error;
    }
  }

  async getUserProjectSubscriptions(userId: string): Promise<any[]> {
    return this.getProjectSubscriptions(userId);
  }

  // Preventive methods
  async getProjectPreventivesByCategory(category: string): Promise<ProjectPreventive[]> {
    try {
      return await prisma.projectPreventive.findMany({
        where: { category: category as any, isActive: true }
      });
    } catch (error) {
      console.error('Error getting project preventives by category:', error);
      return [];
    }
  }

  async getProjectPreventive(id: string): Promise<ProjectPreventive | undefined> {
    try {
      const preventive = await prisma.projectPreventive.findUnique({
        where: { id }
      });
      return preventive || undefined;
    } catch (error) {
      console.error('Error getting project preventive:', error);
      return undefined;
    }
  }

  // Like checking methods
  async isPostLikedByUser(postId: string, userId: string): Promise<boolean> {
    try {
      const like = await prisma.postLike.findUnique({
        where: {
          postId_userId: { postId, userId }
        }
      });
      return !!like;
    } catch (error) {
      console.error('Error checking if post is liked by user:', error);
      return false;
    }
  }

  // Job import methods
  async createJobImport(jobImportData: any): Promise<any> {
    try {
      return await prisma.jobImport.create({
        data: jobImportData
      });
    } catch (error) {
      console.error('Error creating job import record:', error);
      throw error;
    }
  }

  async getJobImports(limit: number = 50): Promise<any[]> {
    try {
      return await prisma.jobImport.findMany({
        orderBy: { importedAt: 'desc' },
        take: limit
      });
    } catch (error) {
      console.error('Error getting job imports:', error);
      return [];
    }
  }

  // Stats methods
  async getActiveProfessionalsCount(): Promise<number> {

  async isCommentLikedByUser(commentId: string, userId: string): Promise<boolean> {
    try {
      const like = await prisma.commentLike.findUnique({
        where: {
          commentId_userId: { commentId, userId }
        }
      });
      return !!like;
    } catch (error) {
      console.error('Error checking if comment is liked by user:', error);
      return false;
    }
  }

  async isProjectLikedByUser(projectId: string, userId: string): Promise<boolean> {
    try {
      const like = await prisma.projectLike.findUnique({
        where: {
          projectId_userId: { projectId, userId }
        }
      });
      return !!like;
    } catch (error) {
      console.error('Error checking if project is liked by user:', error);
      return false;
    }
  }

  // Message methods
  async getConversation(userId1: string, userId2: string): Promise<Message[]> {
    return this.getMessages(userId1, userId2);
  }

  async sendMessage(message: InsertMessage): Promise<Message> {
    return this.createMessage(message);
  }

  async getUnreadMessagesCount(userId: string): Promise<number> {
    return this.getUnreadMessageCount(userId);
  }

  // Connection methods
  async getConnectionStatus(userId1: string, userId2: string): Promise<Connection | undefined> {
    return this.getConnection(userId1, userId2);
  }

  // Feedback methods
  async getFeedbackForUser(toUserId: string): Promise<any[]> {
    return this.getFeedback(toUserId);
  }

  // Notification methods
  async getUnreadNotificationsCount(userId: string): Promise<number> {
    return this.getUnreadNotificationCount(userId);
  }

  async upsertNotificationPreferences(userId: string, preferences: Partial<InsertNotificationPreferences>): Promise<NotificationPreferences> {
    return this.updateNotificationPreferences(userId, preferences);
  }

  async markConversationAsRead(userId1: string, userId2: string): Promise<void> {
    return this.markMessagesAsRead(userId1, userId2);
  }

  // Stats methods
  async getActiveProfessionalsCount(): Promise<number> {
    try {
      return await prisma.professionalProfile.count({
        where: { availability: 'AVAILABLE' }
      });
    } catch (error) {
      console.error('Error getting active professionals count:', error);
      return 0;
    }
  }

  async getOpenProjectsCount(): Promise<number> {
    try {
      return await prisma.project.count({
        where: { status: 'OPEN' }
      });
    } catch (error) {
      console.error('Error getting open projects count:', error);
      return 0;
    }
  }

  // Connection methods
  async getConnectionStatus(userId1: string, userId2: string): Promise<Connection | undefined> {
    return this.getConnection(userId1, userId2);
  }

  async getConnectionById(connectionId: string): Promise<Connection | undefined> {
    try {
      const connection = await prisma.connection.findUnique({
        where: { id: connectionId }
      });
      return connection || undefined;
    } catch (error) {
      console.error('Error getting connection by id:', error);
      return undefined;
    }
  }
}

// Export extended singleton instance
export const extendedStorage = new ExtendedDatabaseStorage();
          respondedAt: new Date()
        }
      });
    } catch (error) {
      console.error('Error updating project application status:', error);
      throw error;
    }
  }

  async getProjectApplicationsCount(projectId: string): Promise<number> {
    try {
      return await prisma.projectApplication.count({
        where: { projectId }
      });
    } catch (error) {
      console.error('Error getting project applications count:', error);
      return 0;
    }
  }

  async getAcceptedProjectApplicationsCount(projectId: string): Promise<number> {
    try {
      return await prisma.projectApplication.count({
        where: { projectId, status: 'ACCEPTED' }
      });
    } catch (error) {
      console.error('Error getting accepted project applications count:', error);
      return 0;
    }
  }

  // Project preventive operations
  async getProjectPreventives(userId: string): Promise<ProjectPreventive[]> {
    try {
      return await prisma.projectPreventive.findMany({
        where: { userId }
      });
    } catch (error) {
      console.error('Error getting project preventives:', error);
      return [];
    }
  }

  async createProjectPreventive(preventive: InsertProjectPreventive): Promise<ProjectPreventive> {
    try {
      return await prisma.projectPreventive.create({
        data: preventive
      });
    } catch (error) {
      console.error('Error creating project preventive:', error);
      throw error;
    }
  }

  async updateProjectPreventive(id: string, preventive: Partial<InsertProjectPreventive>): Promise<ProjectPreventive> {
    try {
      return await prisma.projectPreventive.update({
        where: { id },
        data: preventive
      });
    } catch (error) {
      console.error('Error updating project preventive:', error);
      throw error;
    }
  }

  async deleteProjectPreventive(id: string): Promise<void> {
    try {
      await prisma.projectPreventive.delete({
        where: { id }
      });
    } catch (error) {
      console.error('Error deleting project preventive:', error);
      throw error;
    }
  }

  async validateProjectAgainstPreventives(project: InsertProject, userId: string): Promise<string[]> {
    try {
      const preventives = await prisma.projectPreventive.findMany({
        where: {
          OR: [
            { userId, isActive: true },
            { isGlobal: true, isActive: true }
          ]
        }
      });

      const errors: string[] = [];

      for (const preventive of preventives) {
        try {
          const rule = JSON.parse(preventive.validationRule);
          // Here you would implement the actual validation logic
          // This is a simplified example
          if (rule.type === 'budgetMin' && project.budgetMin && project.budgetMin < rule.value) {
            errors.push(preventive.errorMessage);
          }
          if (rule.type === 'budgetMax' && project.budgetMax && project.budgetMax > rule.value) {
            errors.push(preventive.errorMessage);
          }
        } catch (parseError) {
          console.error('Error parsing validation rule:', parseError);
        }
      }

      return errors;
    } catch (error) {
      console.error('Error validating project against preventives:', error);
      return [];
    }
  }
}

// Export singleton instance
export const storage = new DatabaseStorage();